### Need check: Lemma 3.1, 3.10, 3.13, (notebooke) Corollary 2.7 and Example 3.17, 5.4

### Gssp sequence
### Author: Jephian Lin

### Tested under SageMath 9.0
### See the illustration file Gssp_illustration.ipynb on
### https://github.com/jephianlin/publish

### Quick Sample
"""
### Gssp_sequence will return
### True or False
### (whether there is a Gssp sequence
###  starting from g and ending with a complete graph), 
### and a sequence of forces
sage: g = graphs.PathGraph(5)
sage: Gssp_sequence(g)
(True,
 [(1, ((1, 0), (0, 2))),
  (1, ((2, 0), (0, 3))),
  (1, ((2, 1), (1, 3))),
  (1, ((3, 0), (0, 4))),
  (1, ((0, 4), (4, 1))),
  (1, ((1, 4), (4, 2)))])

### If print_force=True
### then typeset the forces
sage: g = graphs.PathGraph(5)
sage: forces = Gssp_sequence(g, print_force=True)
Rule 1: {1,0} --> {0,2}
Rule 1: {2,0} --> {0,3}
Rule 1: {2,1} --> {1,3}
Rule 1: {3,0} --> {0,4}
Rule 1: {0,4} --> {4,1}
Rule 1: {1,4} --> {4,2}
"""

### GENERAL FUNCTIONS
def typeset_force(rule_num, force):
    """
    Input:
        rule_num: integer 1, 2, or 3
        force: one of the three format
            Rule 1. ((i,j), (j,k))
            Rule 2. (i, C), 
                where C = [v1, ..., vn] is a cycle
            Rule 3. (Y_center, Y_branch1, Y_branch2, Y_branch3, h),
                where Y is a Y graph and h is an integer
    Output:
        print the force in a readable way
    """
    if rule_num == 1:
        i,j = force[0]
        if j != force[1][0]:
            raise ValueError("force[0][1] != force[1][0]")
        k = force[1][1]
        print("Rule 1: {%s,%s} --> {%s,%s}"%(i,j,j,k))
        
    if rule_num == 2:
        i,C = force
        print("Rule 2: %s --> %s"%(i,C))
        
    if rule_num == 3:
        Y_center, Y_branch1, Y_branch2, Y_branch3, h = force
        print("Rule 3: Y_h^(h) --> Y_h^(h+1)")
        print("        Y centered at %s with h = %s"%(Y_center,h))
        print("        branch1 %s"%Y_branch1)
        print("        branch2 %s"%Y_branch2)
        print("        branch3 %s"%Y_branch3)
        
def is_complete(g):
    """
    Input:
        g: a simple graph
    Output:
        return whether g is a complete graph or not
    """
    n = g.order()
    m = g.size()
    return m == n*(n-1)/2

### Y GRAPH RELATED
def Y_graph(a, b=None, c=None):
    """
    Input:
        a,b,c: integers, 
            the number of vertices on each branch
            not including the center vertex
    Output:
        the graph Y_{a,b,c}, 
        when b or c is not specified, 
        its value will be replaced by a
    """
    if b == None:
        b = a
    if c == None:
        c = a
    g = graphs.PathGraph(a+b+c+1)
    g.set_pos(None)
    g.delete_edges([(a,a+1), (a+b,a+b+1)])
    g.add_edges([(0,a+1), (0,a+b+1)])
    return g

def find_all_Y(g):
    """
    Input:
        g: graph
    Output:
        return all induced subgraphs that is 
        isomorphic to some Yh
    """
    Ys = []
    Y_sets = []
    for h in range(1,g.order()):
        for Y in g.subgraph_search_iterator(Y_graph(h), True):
            if set(Y) not in Y_sets:
                Ys.append(Y)
                Y_sets.append(set(Y))
    return Ys

def Y_separator(Y):
    """
    Input:
        Y: a list of 3h+1 vertices (in good order)
            that is the vertices of some Yh
    Output:
        Return (Y_center, Y_branch1, Y_branch2, Y_branch3, h)
        See the code for the meaning of these sets
    """
    h = int((len(Y)-1) / 3)
    Y_center = Y[0]
    Y_branch1 = Y[1:h+1]
    Y_branch2 = Y[h+1:2*h+1]
    Y_branch3 = Y[2*h+1:]
    return (Y_center, Y_branch1, Y_branch2, Y_branch3, h)

def Y_distance(Y_center, Y_branch1, Y_branch2, Y_branch3, d, compare='=='):
    """
    Input:
        Y_center, Y_branch1, Y_branch2, Y_branch3:
            information about Y generated by Y_separator
        d: the target distance
    Output: 
        By default, it will reconstruct the Y graph 
        and return the list of unordered pairs (i,j) 
        whose distance is == d
        When compare is given, '==' can be changed to other operators.
        """
    ### construct the Y graph
    Y = Graph(0)
    Y.add_vertex(Y_center)
    for branch in [Y_branch1, Y_branch2, Y_branch3]:
        for i in branch:
            Y.add_vertex(i)
        Y.add_edge(Y_center, branch[0])
        for i,j in zip(branch[:-1],branch[1:]):
            Y.add_edge(i,j)
    ### collect all unordered pair (i,j)
    ### whose distance is = d
    pairs = []
    distances = Y.distance_all_pairs()
    for i,j in Combinations(Y.vertices(),2):
        if eval("distances[i][j] %s d"%compare):
            pairs.append((i,j))
    return pairs

### RULES 1, 2, and 3
def find_rule1(g, gl, print_force=False):
    """
    Input:
        g: base graph
        gl: gray graph 
            (a supergraph of g of the same order)
        print_force: boolean
            print the force if True
    Output:
        Update gl (so never do gl = g) and 
        return a force {i,j} --> {j,k} in the form of ((i,j), (j,k)),
        or return None
        [Ref. Lemma 3.1] 
    """
    found = False
    for e in gl.edges(labels=False):
        ### Rule 1 happens only when 
        ### i,j,k are distinct
        ### and {i,j} is an edge of gl
        i,j = e
        ### ikj = N_g[i] cap N_gl[j]^c
        ikj = [k for k in g.neighbors(i) if k not in gl.neighbors(j) and k != j]
        ### jki = N_g[j] cap N_gl[i]^c
        jki = [k for k in g.neighbors(j) if k not in gl.neighbors(i) and k != i]
        if len(ikj) == 1 and len(jki) == 0:
            ### i,j = i,j
            k = ikj[0]
            found = True
            break
        if len(jki) == 1 and len(ikj) == 0:
            i,j = j,i
            k = jki[0]
            found = True
            break
    if found:
        force = ((i,j),(j,k))
        gl.add_edge(j,k)
        if print_force:
            typeset_force(1, force)
        return force
    else:
        return None

def find_rule2(g, gl, print_force=False):
    """
    Input:
        g: base graph
        gl: gray graph 
            (a supergraph of g of the same order)
        print_force: boolean
            print the force if True
    Output:
        Update gl (so never do gl = g) and 
        return a force i --> C in the form of (i, [v1, ..., vs]),
        where [v1, ..., vs] is the vertices of C in cycle order,
        or return None 
        [Ref. Lemma 3.10] 
    """
    glbar = gl.complement()
    for i in g.vertices():
        ### ind_glbar = glbar induced on N_g(i)
        ind_glbar = glbar.subgraph(g.neighbors(i))
        for C in ind_glbar.connected_components_subgraphs():
            deg_seq = C.degree_sequence()
            deg_seq.sort()
            nC = C.order()
            ### if C is an odd cycle
            if deg_seq[0] == 2 and deg_seq[-1] == 2 and nC%2 == 1:
                ### construct js as the vertices of h
                ### in cycle order
                VC = C.vertices()
                js = [None]*nC
                js[0] = VC[0]
                for _ in range(nC-1):
                    js[_+1] = [v for v in C.neighbors(js[_]) if v != js[_-1]][0]
                ### check if ij is focused on V(C)
                for j in js:
                    ### ikj = N_g[i] cap N_gl[j]^c
                    ikj = [k for k in g.neighbors(i) if k not in gl.neighbors(j) and k != j]
                    ### jki = N_g[j] cap N_gl[i]^c
                    jki = [k for k in g.neighbors(j) if k not in gl.neighbors(i) and k != i]
                    if len(ikj) != 2 or len(jki) != 0:
                        break
                ### when len(ikj) == 2 and len(jki) == 0
                ### for all j in js
                else:
                    force = (i, js)
                    new_edges = [(js[_-1],js[_]) for _ in range(nC)]
                    gl.add_edges(new_edges)
                    if print_force:
                        typeset_force(2, force)
                    return force
    ### if nothing found
    return None
                
def find_rule3(g, gl, print_force=False, Ys=None):
    """
    Input:
        g: base graph
        gl: gray graph 
            (a supergraph of g of the same order)
        print_force: boolean
            print the force if True
        Ys: a list of (vertices of) Y induced subgraphs of g
            if None, compute this list
            This input can be generated by find_all_Y(g)
    Output:
        Update gl (so never do gl = g) and 
        return a force Y_h^(h) --> Y_h^(h+1) 
        in the form of (Y_center, Y_branch1, Y_branch2, Y_branch3, h),
        or return None 
        [Ref. Lemma 3.13] 
    """
    if Ys == None:
        Ys = find_all_Y(g)
    for Y in Ys:
        Y_center, Y_branch1, Y_branch2, Y_branch3, h = Y_separator(Y)
        ### shorts = list of edge in Y^h
        ### forcers = list of edges in Y^(h)
        ### forcees = list of edges in Y^(h+1)
        shorts = Y_distance(Y_center, Y_branch1, Y_branch2, Y_branch3, h, '<=')
        forcers = Y_distance(Y_center, Y_branch1, Y_branch2, Y_branch3, h)
        forcees = Y_distance(Y_center, Y_branch1, Y_branch2, Y_branch3, h+1)
        ### check if shorts contained in gl
        ### if not, skip the loop
        out = [e for e in shorts if not gl.has_edge(e)]
        if len(out) != 0:
            continue
        ### check if forcees not contained in gl
        ### if not, skip the loop
        out = [e for e in forcees if gl.has_edge(e)]
        if len(out) != 0:
            continue
        ### check if all forcers is focused on V(Y)
        for i,j in forcers:
            ### ikj = N_g[i] cap N_gl[j]^c
            ikj = [k for k in g.neighbors(i) if k not in gl.neighbors(j) and k != j]
            ### jki = N_g[j] cap N_gl[i]^c
            jki = [k for k in g.neighbors(j) if k not in gl.neighbors(i) and k != i]
            if len(ikj) + len(jki) != 2:
                break
        ### when all forcers are focused on V(Y)
        else:
            force = (Y_center, Y_branch1, Y_branch2, Y_branch3, h)
            gl.add_edges(forcees)
            if print_force:
                typeset_force(3, force)
            return force
    ### if nothing found
    return None
    
### MAIN FUNCTION
def Gssp_sequence(g, print_force=False):
    """
    Input:
        g: graph
        print_force: boolean
            print the force if True
    Output:
        Return (boolean, forces), 
        where forces is the Gssp sequence 
        with the format (rule number, force) and 
        boolean is whether the sequence ends
        with a complete graph
        """
    gl = g.copy()
    again = True
    forces = []
    
    ### pre-calculate induced Y subgraphs of g
    ### to make Rule 3 faster
    Ys = find_all_Y(g)
    
    while again:
        ### check rule1 > rule2 > rule3
        ### when the previous rule found something
        ### ignore the later rules 
        ### and search again
        ### stop only when nothing found
        for num in [1,2,3]:
            find = eval("find_rule%s"%num)
            if num in [1,2]:
                force = find(g, gl, print_force)
            else: ### num == 3
                force = find(g, gl, print_force, Ys)
            if force != None:
                forces.append((num, force))
                break
        else:
            again = False
    return (is_complete(gl), forces)


### FUNCTIONS COPIED FROM https://github.com/jephianlin/minrank_aux

### from general_Lib.py
def var_matrix(g):
    """
    Input:
        g: a simple graph
    Output:
        a matrix with variable a1_j on ij-entry if ij is an edge, and a variable di on diagonal.
    
    """
    n=g.order()
    A=matrix(n,[var("x")]*(n^2));
    E=g.edges(labels=False);
    Ebar=g.complement().edges(labels=False);
    V=g.vertices();
    for v in V:
        A[v,v]=var("d%s"%v);
    for e in E:
        i=min(e);
        j=max(e);
        A[i,j]=var("a%s_%s"%(i,j));
        A[j,i]=var("a%s_%s"%(i,j));
    for e in Ebar:
        i,j=e;
        A[i,j]=0;
        A[j,i]=0; 
    return A;

### from SXP.sage
def SSPmatrix(A, return_index=False):
    """
    Input: 
        A: a symmetric matrix;
        return_index: if True, also return two dictionaries
                    row_index={pair: row index}
                    column_index={nonedge: col index}
    Output: 
        the linear system given by SSP conditions;
    """
    n=A.dimensions()[0];
    R=A.base_ring();
    row_index={}; #{n+1 choose 2} restrictions
    column_index={}; #|E(Gbar)| variables
    res_counter=0;
    var_counter=0;
    for i in range(0,n):
        for j in range(i+1,n):
            row_index[i,j]=res_counter;
            res_counter+=1
            if A[i,j]==0:
                column_index[i,j]=var_counter;
                column_index[j,i]=var_counter; 
                var_counter+=1;
    SSP_sys=matrix(R,res_counter,var_counter);
    for i in range(0,n):
        for j in range(i+1,n):
            for k in range(n):
                if k!=j and A[k,j]==0:
                    SSP_sys[row_index[i,j],column_index[k,j]]+=A[i,k];
                if i!=k and A[i,k]==0:
                    SSP_sys[row_index[i,j],column_index[i,k]]-=A[k,j];
    if return_index:
        keys=column_index.keys();
        for a,b in keys:
            if a>b:
                c=column_index.pop((a,b));
        return SSP_sys,row_index,column_index;
    else:
        return SSP_sys;